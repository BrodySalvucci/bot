{
    "sourceFile": "src/http.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 2,
            "patches": [
                {
                    "date": 1737684080506,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1737684256892,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -38,9 +38,9 @@\n \t\t\t\tid: client.user.id,\n \t\t\t\tsecret: process.env.DISCORD_SECRET,\n \t\t\t},\n \t\t},\n-\t\tgenerateStateFunction: req => {\n+\t\tgenerateStateFunction: (req, res) => {\n \t\t\tconst state = randomBytes(12).toString('hex');\n \t\t\tfastify.states.set(state, req.query.r || '/');\n \t\t\tres.setCookie('oauth2-redirect-state', state, {\n \t\t\t\thttpOnly: true,\n"
                },
                {
                    "date": 1737684278155,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -45,9 +45,9 @@\n \t\t\tres.setCookie('oauth2-redirect-state', state, {\n \t\t\t\thttpOnly: true,\n \t\t\t\tpath: '/',\n \t\t\t\tsecure: process.env.NODE_ENV === 'production',\n-\t\t\t\tsameSite: 'Lax'\n+\t\t\t\tsameSite: 'Lax',\n \t\t\t});\n \t\t\treturn state;\n \t\t},\n \t\tname: 'discord',\n"
                }
            ],
            "date": 1737684080506,
            "name": "Commit-0",
            "content": "const fastify = require('fastify')({ trustProxy: process.env.HTTP_TRUST_PROXY === 'true' });\nconst oauth = require('@fastify/oauth2');\nconst { randomBytes } = require('crypto');\nconst { short } = require('leeks.js');\nconst { join } = require('path');\nconst { files } = require('node-dir');\nconst { getPrivilegeLevel } = require('./lib/users');\n\nprocess.env.ORIGIN = process.env.HTTP_INTERNAL || process.env.HTTP_EXTERNAL;\n\nmodule.exports = async client => {\n\t// cookies plugin, must be registered before oauth2 since oauth2@7.2.0\n\tfastify.register(require('@fastify/cookie'));\n\n\t// jwt plugin\n\tfastify.register(require('@fastify/jwt'), {\n\t\tcookie: {\n\t\t\tcookieName: 'token',\n\t\t\tsigned: false,\n\t\t},\n\t\tsecret: process.env.ENCRYPTION_KEY,\n\t});\n\n\t// oauth2 plugin\n\tfastify.states = new Map();\n\tfastify.register(oauth, {\n\t\tcallbackUri: `${process.env.HTTP_EXTERNAL}/auth/callback`,\n\t\tcallbackUriParams: { prompt: 'none' },\n\t\tcheckStateFunction: async req => {\n\t\t\tif (req.query.state !== req.cookies['oauth2-redirect-state']) {\n\t\t\t\tthrow new Error('Invalid state');\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\t\tcredentials: {\n\t\t\tauth: oauth.DISCORD_CONFIGURATION,\n\t\t\tclient: {\n\t\t\t\tid: client.user.id,\n\t\t\t\tsecret: process.env.DISCORD_SECRET,\n\t\t\t},\n\t\t},\n\t\tgenerateStateFunction: req => {\n\t\t\tconst state = randomBytes(12).toString('hex');\n\t\t\tfastify.states.set(state, req.query.r || '/');\n\t\t\tres.setCookie('oauth2-redirect-state', state, {\n\t\t\t\thttpOnly: true,\n\t\t\t\tpath: '/',\n\t\t\t\tsecure: process.env.NODE_ENV === 'production',\n\t\t\t\tsameSite: 'Lax'\n\t\t\t});\n\t\t\treturn state;\n\t\t},\n\t\tname: 'discord',\n\t\tscope: ['applications.commands.permissions.update', 'guilds', 'identify'],\n\t\tstartRedirectPath: '/auth/login',\n\t});\n\n\n\t// auth\n\tfastify.decorate('authenticate', async (req, res) => {\n\t\ttry {\n\t\t\tconst data = await req.jwtVerify();\n\t\t\tif (data.expiresAt < Date.now()) throw 'expired';\n\t\t\tif (data.createdAt < new Date(process.env.INVALIDATE_TOKENS).getTime()) throw 'expired';\n\t\t} catch (error) {\n\t\t\treturn res.code(401).send({\n\t\t\t\terror: 'Unauthorised',\n\t\t\t\tmessage: error === 'expired' ? 'Your token has expired; please re-authenticate.' : 'You are not authenticated.',\n\t\t\t\tstatusCode: 401,\n\t\t\t});\n\t\t}\n\t});\n\n\tfastify.decorate('isMember', async (req, res) => {\n\t\ttry {\n\t\t\tconst userId = req.user.id;\n\t\t\tconst guildId = req.params.guild;\n\t\t\tconst guild = client.guilds.cache.get(guildId);\n\t\t\tif (!guild) {\n\t\t\t\treturn res.code(404).send({\n\t\t\t\t\terror: 'Not Found',\n\t\t\t\t\tmessage: 'The requested resource could not be found.',\n\t\t\t\t\tstatusCode: 404,\n\n\t\t\t\t});\n\t\t\t}\n\t\t\tconst guildMember = await guild.members.fetch(userId);\n\t\t\tif (!guildMember) {\n\t\t\t\treturn res.code(403).send({\n\t\t\t\t\terror: 'Forbidden',\n\t\t\t\t\tmessage: 'You are not permitted for this action.',\n\t\t\t\t\tstatusCode: 403,\n\n\t\t\t\t});\n\t\t\t}\n\t\t} catch (err) {\n\t\t\tres.send(err);\n\t\t}\n\t});\n\n\tfastify.decorate('isAdmin', async (req, res) => {\n\t\ttry {\n\t\t\tconst userId = req.user.id;\n\t\t\tconst guildId = req.params.guild;\n\t\t\tconst guild = client.guilds.cache.get(guildId);\n\t\t\tif (!guild) {\n\t\t\t\treturn res.code(404).send({\n\t\t\t\t\terror: 'Not Found',\n\t\t\t\t\tmessage: 'The requested resource could not be found.',\n\t\t\t\t\tstatusCode: 404,\n\n\t\t\t\t});\n\t\t\t}\n\t\t\tif (client.banned_guilds.has(guildId)) {\n\t\t\t\treturn res.code(451).send({\n\t\t\t\t\terror: 'Unavailable For Legal Reasons',\n\t\t\t\t\tmessage: 'This guild has been banned for breaking the terms of service.',\n\t\t\t\t\tstatusCode: 451,\n\n\t\t\t\t});\n\t\t\t}\n\t\t\tconst guildMember = await guild.members.fetch(userId);\n\t\t\tconst isAdmin = await getPrivilegeLevel(guildMember) >= 2;\n\t\t\tif (!isAdmin) {\n\t\t\t\treturn res.code(403).send({\n\t\t\t\t\terror: 'Forbidden',\n\t\t\t\t\tmessage: 'You are not permitted for this action.',\n\t\t\t\t\tstatusCode: 403,\n\n\t\t\t\t});\n\t\t\t}\n\t\t} catch (err) {\n\t\t\tres.send(err);\n\t\t}\n\t});\n\n\t// body processing\n\tfastify.addHook('preHandler', (req, res, done) => {\n\t\tif (req.body && typeof req.body === 'object') {\n\t\t\tfor (const prop in req.body) {\n\t\t\t\tif (typeof req.body[prop] === 'string') {\n\t\t\t\t\treq.body[prop] = req.body[prop].trim();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdone();\n\t});\n\n\t// logging\n\tfastify.addHook('onResponse', (req, res, done) => {\n\t\tdone();\n\t\tconst status = (res.statusCode >= 500\n\t\t\t? '&4'\n\t\t\t: res.statusCode >= 400\n\t\t\t\t? '&6'\n\t\t\t\t: res.statusCode >= 300\n\t\t\t\t\t? '&3'\n\t\t\t\t\t: res.statusCode >= 200\n\t\t\t\t\t\t? '&2'\n\t\t\t\t\t\t: '&f') + res.statusCode;\n\t\tlet responseTime = res.elapsedTime.toFixed(2);\n\t\tresponseTime = (responseTime >= 100\n\t\t\t? '&c'\n\t\t\t: responseTime >= 10\n\t\t\t\t? '&e'\n\t\t\t\t: '&a') + responseTime + 'ms';\n\t\tconst level = req.routeOptions.url === '/status'\n\t\t\t? 'debug'\n\t\t\t:  req.routeOptions.url === '/*'\n\t\t\t\t? 'verbose'\n\t\t\t\t: 'info';\n\t\tclient.log[level].http(short(`${req.id} ${req.ip} ${req.method} ${req.routeOptions.url ?? '*'} &m-+>&r ${status}&b in ${responseTime}`));\n\t\tif (!req.routeOptions.url) client.log.verbose.http(`${req.id} ${req.method} ${req.url}`);\n\t\tdone();\n\t});\n\n\tfastify.addHook('onError', async (req, res, err) => client.log.error.http(req.id, err));\n\n\t// route loading\n\tconst dir = join(__dirname, '/routes');\n\tfiles(dir, {\n\t\texclude: /^\\./,\n\t\tmatch: /.js$/,\n\t\tsync: true,\n\t}).forEach(file => {\n\t\tconst path = file\n\t\t\t.substring(0, file.length - 3) // remove `.js`\n\t\t\t.substring(dir.length) // remove higher directories\n\t\t\t.replace(/\\\\/g, '/') // replace `\\` with `/` because Windows is stupid\n\t\t\t.replace(/\\[(\\w+)\\]/gi, ':$1') // convert [] to :\n\t\t\t.replace('/index', '') || '/'; // remove index\n\t\tconst route = require(file);\n\n\t\tObject.keys(route).forEach(method => fastify.route({\n\t\t\tconfig: { client },\n\t\t\tmethod: method.toUpperCase(),\n\t\t\tpath,\n\t\t\t...route[method](fastify),\n\t\t})); // register route\n\t});\n\n\tconst { handler } = await import('@discord-tickets/settings/build/handler.js');\n\n\t// https://stackoverflow.com/questions/72317071/how-to-set-up-fastify-correctly-so-that-sveltekit-works-fine\n\tfastify.all('/*', {}, (req, res) => handler(req.raw, res.raw, () => { }));\n\n\t// start the fastify server\n\tfastify.listen({\n\t\thost: process.env.HTTP_HOST,\n\t\tport: process.env.HTTP_PORT,\n\t}, (err, addr) => {\n\t\tif (err) client.log.error.http(err);\n\t\telse client.log.success.http(`Listening at ${addr}`);\n\t});\n\n\tprocess.on('sveltekit:error', ({\n\t\terror,\n\t\terrorId,\n\t}) => {\n\t\tclient.log.error.http(`SvelteKit ${errorId} ${error}`);\n\t});\n};\n"
        }
    ]
}