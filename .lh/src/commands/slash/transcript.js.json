{
    "sourceFile": "src/commands/slash/transcript.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1737683858302,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1737683858302,
            "name": "Commit-0",
            "content": "const { SlashCommand } = require('@eartharoid/dbf');\nconst {\n\tApplicationCommandOptionType,\n\tPermissionsBitField,\n} = require('discord.js');\nconst fs = require('fs');\nconst { join } = require('path');\nconst Mustache = require('mustache');\nconst { AttachmentBuilder } = require('discord.js');\nconst Cryptr = require('cryptr');\nconst { decrypt } = new Cryptr(process.env.ENCRYPTION_KEY);\nconst ExtendedEmbedBuilder = require('../../lib/embed');\n\nmodule.exports = class TranscriptSlashCommand extends SlashCommand {\n\tconstructor(client, options) {\n\t\tconst name = 'transcript';\n\t\tsuper(client, {\n\t\t\t...options,\n\t\t\tdescription: client.i18n.getMessage(null, `commands.slash.${name}.description`),\n\t\t\tdescriptionLocalizations: client.i18n.getAllMessages(`commands.slash.${name}.description`),\n\t\t\tdmPermission: false,\n\t\t\tname,\n\t\t\tnameLocalizations: client.i18n.getAllMessages(`commands.slash.${name}.name`),\n\t\t\toptions: [\n\t\t\t\t{\n\t\t\t\t\tautocomplete: true,\n\t\t\t\t\tname: 'ticket',\n\t\t\t\t\trequired: true,\n\t\t\t\t\ttype: ApplicationCommandOptionType.String,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tname: 'member',\n\t\t\t\t\trequired: false,\n\t\t\t\t\ttype: ApplicationCommandOptionType.User,\n\t\t\t\t},\n\t\t\t].map(option => {\n\t\t\t\toption.descriptionLocalizations = client.i18n.getAllMessages(`commands.slash.${name}.options.${option.name}.description`);\n\t\t\t\toption.description = option.descriptionLocalizations['en-GB'];\n\t\t\t\toption.nameLocalizations = client.i18n.getAllMessages(`commands.slash.${name}.options.${option.name}.name`);\n\t\t\t\treturn option;\n\t\t\t}),\n\t\t});\n\n\t\tMustache.escape = text => text; // don't HTML-escape\n\t\tthis.template = fs.readFileSync(\n\t\t\tjoin('./user/templates/', this.client.config.templates.transcript + '.mustache'),\n\t\t\t{ encoding: 'utf8' },\n\t\t);\n\t}\n\n\tshouldAllowAccess(interaction, ticket)  {\n\t\tif (interaction.guild.id !== ticket.guildId) return false;\n\t\tif (ticket.createdById === interaction.member.id) return true;\n\t\tif (interaction.client.supers.includes(interaction.member.id)) return true;\n\t\tif (interaction.member.permissions.has(PermissionsBitField.Flags.ManageGuild)) return true;\n\t\tif (interaction.member.roles.cache.filter(role => ticket.category.staffRoles.includes(role.id)).size > 0) return true;\n\t\treturn false;\n\t}\n\n\tasync fillTemplate(ticket) {\n\t\t/** @type {import(\"client\")} */\n\t\tconst client = this.client;\n\n\t\tticket.claimedBy = ticket.archivedUsers.find(u => u.userId === ticket.claimedById);\n\t\tticket.closedBy = ticket.archivedUsers.find(u => u.userId === ticket.closedById);\n\t\tticket.createdBy = ticket.archivedUsers.find(u => u.userId === ticket.createdById);\n\n\t\tif (ticket.closedReason) ticket.closedReason = decrypt(ticket.closedReason);\n\t\tif (ticket.feedback?.comment) ticket.feedback.comment = decrypt(ticket.feedback.comment);\n\t\tif (ticket.topic) ticket.topic = decrypt(ticket.topic).replace(/\\n/g, '\\n\\t');\n\n\t\tticket.archivedUsers.forEach((user, i) => {\n\t\t\tif (user.displayName) user.displayName = decrypt(user.displayName);\n\t\t\tuser.username = decrypt(user.username);\n\t\t\tticket.archivedUsers[i] = user;\n\t\t});\n\n\t\tticket.archivedMessages.forEach((message, i) => {\n\t\t\tmessage.author = ticket.archivedUsers.find(u => u.userId === message.authorId);\n\t\t\tmessage.content = JSON.parse(decrypt(message.content));\n\t\t\tmessage.text = message.content.content?.replace(/\\n/g, '\\n\\t') ?? '';\n\t\t\tmessage.content.attachments?.forEach(a => (message.text += '\\n\\t' + a.url));\n\t\t\tmessage.content.embeds?.forEach(() => (message.text += '\\n\\t[embedded content]'));\n\t\t\tmessage.number = 'M' + String(i + 1).padStart(ticket.archivedMessages.length.toString().length, '0');\n\t\t\tticket.archivedMessages[i] = message;\n\t\t});\n\n\t\tticket.pinnedMessageIds = ticket.pinnedMessageIds.map(id => ticket.archivedMessages.find(message => message.id === id)?.number);\n\n\t\tconst channelName = ticket.category.channelName\n\t\t\t.replace(/{+\\s?(user)?name\\s?}+/gi, ticket.createdBy?.username)\n\t\t\t.replace(/{+\\s?(nick|display)(name)?\\s?}+/gi, ticket.createdBy?.displayName)\n\t\t\t.replace(/{+\\s?num(ber)?\\s?}+/gi, ticket.number);\n\t\tconst fileName = `${channelName}.${this.client.config.templates.transcript.split('.').slice(-1)[0]}`;\n\t\tconst transcript = Mustache.render(this.template, {\n\t\t\tchannelName,\n\t\t\tclosedAtFull: function () {\n\t\t\t\treturn new Intl.DateTimeFormat([ticket.guild.locale, 'en-GB'], {\n\t\t\t\t\tdateStyle: 'full',\n\t\t\t\t\ttimeStyle: 'long',\n\t\t\t\t\ttimeZone: 'Etc/UTC',\n\t\t\t\t}).format(this.closedAt);\n\t\t\t},\n\t\t\tcreatedAtFull: function () {\n\t\t\t\treturn new Intl.DateTimeFormat([ticket.guild.locale, 'en-GB'], {\n\t\t\t\t\tdateStyle: 'full',\n\t\t\t\t\ttimeStyle: 'long',\n\t\t\t\t\ttimeZone: 'Etc/UTC',\n\t\t\t\t}).format(this.createdAt);\n\t\t\t},\n\t\t\tcreatedAtTimestamp: function () {\n\t\t\t\treturn new Intl.DateTimeFormat([ticket.guild.locale, 'en-GB'], {\n\t\t\t\t\tdateStyle: 'short',\n\t\t\t\t\ttimeStyle: 'long',\n\t\t\t\t\ttimeZone: 'Etc/UTC',\n\t\t\t\t}).format(this.createdAt);\n\t\t\t},\n\t\t\tguildName: client.guilds.cache.get(ticket.guildId)?.name,\n\t\t\tpinned: ticket.pinnedMessageIds.join(', '),\n\t\t\tticket,\n\t\t});\n\n\t\treturn {\n\t\t\tfileName,\n\t\t\ttranscript,\n\t\t};\n\t}\n\n\t/**\n\t * @param {import(\"discord.js\").ChatInputCommandInteraction} interaction\n\t */\n\tasync run(interaction, ticketId) {\n\t\t/** @type {import(\"client\")} */\n\t\tconst client = this.client;\n\n\t\tawait interaction.deferReply({ ephemeral: true });\n\t\tticketId = ticketId || interaction.options.getString('ticket', true);\n\t\tconst ticket = await client.prisma.ticket.findUnique({\n\t\t\tinclude: {\n\t\t\t\tarchivedChannels: true,\n\t\t\t\tarchivedMessages: {\n\t\t\t\t\torderBy: { createdAt: 'asc' },\n\t\t\t\t\twhere: { external: false },\n\t\t\t\t},\n\t\t\t\tarchivedRoles: true,\n\t\t\t\tarchivedUsers: true,\n\t\t\t\tcategory: true,\n\t\t\t\tclaimedBy: true,\n\t\t\t\tclosedBy: true,\n\t\t\t\tcreatedBy: true,\n\t\t\t\tfeedback: true,\n\t\t\t\tguild: true,\n\t\t\t\tquestionAnswers: true,\n\t\t\t},\n\t\t\twhere: { id: ticketId },\n\t\t});\n\n\t\tif (!ticket) throw new Error(`Ticket ${ticketId} does not exist`);\n\n\t\tif (!this.shouldAllowAccess(interaction, ticket)) {\n\t\t\tconst settings = await client.prisma.guild.findUnique({ where: { id: interaction.guild.id } });\n\t\t\tconst getMessage = client.i18n.getLocale(settings.locale);\n\t\t\treturn await interaction.editReply({\n\t\t\t\tembeds: [\n\t\t\t\t\tnew ExtendedEmbedBuilder({\n\t\t\t\t\t\ticonURL: interaction.guild.iconURL(),\n\t\t\t\t\t\ttext: ticket.guild.footer,\n\t\t\t\t\t})\n\t\t\t\t\t\t.setColor(ticket.guild.errorColour)\n\t\t\t\t\t\t.setTitle(getMessage('commands.slash.transcript.not_staff.title'))\n\t\t\t\t\t\t.setDescription(getMessage('commands.slash.transcript.not_staff.description')),\n\t\t\t\t],\n\t\t\t});\n\t\t}\n\n\t\tconst {\n\t\t\tfileName,\n\t\t\ttranscript,\n\t\t} = await this.fillTemplate(ticket);\n\t\tconst attachment = new AttachmentBuilder()\n\t\t\t.setFile(Buffer.from(transcript))\n\t\t\t.setName(fileName);\n\n\t\t// Save transcript to disk for web access\n\t\tconst transcriptPath = join('./user/transcripts/', fileName);\n\t\tfs.mkdirSync('./user/transcripts/', { recursive: true });\n\t\tfs.writeFileSync(transcriptPath, transcript);\n\n\t\t// Generate portal link\n\t\tconst portalLink = `${process.env.HTTP_EXTERNAL}/transcripts/${ticketId}`;\n\n\t\tawait interaction.editReply({\n\t\t\tembeds: [\n\t\t\t\tnew ExtendedEmbedBuilder({\n\t\t\t\t\ticonURL: interaction.guild.iconURL(),\n\t\t\t\t\ttext: ticket.guild.footer,\n\t\t\t\t})\n\t\t\t\t\t.setColor(ticket.guild.primaryColour)\n\t\t\t\t\t.setDescription(`View this transcript online: ${portalLink}`),\n\t\t\t],\n\t\t\tfiles: [attachment],\n\t\t});\n\t}\n};\n"
        }
    ]
}