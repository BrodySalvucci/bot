{
    "sourceFile": "src/lib/tickets/archiver.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1737687307571,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1737687308084,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -166,5 +166,5 @@\n \t\t\t},\n \t\t\twhere: { id: ticketId },\n \t\t});\n \t}\n-};\n+};\n\\ No newline at end of file\n"
                }
            ],
            "date": 1737687307571,
            "name": "Commit-0",
            "content": "const Cryptr = require('cryptr');\nconst { encrypt } = new Cryptr(process.env.ENCRYPTION_KEY);\n\n/**\n * Returns highest (roles.highest) hoisted role, or everyone\n * @param {import(\"discord.js\").GuildMember} member\n * @returns {import(\"discord.js\").Role}\n */\nconst hoistedRole = member => member.roles.hoist || member.guild.roles.everyone;\n\nmodule.exports = class TicketArchiver {\n\tconstructor(client) {\n\t\t/** @type {import(\"client\")} */\n\t\tthis.client = client;\n\t}\n\n\t/** Add or update a message\n\t * @param {string} ticketId\n\t * @param {import(\"discord.js\").Message} message\n\t * @param {boolean?} external\n\t * @returns {import(\"@prisma/client\").ArchivedMessage|boolean}\n\t */\n\tasync saveMessage(ticketId, message, external = false) {\n\t\tif (process.env.OVERRIDE_ARCHIVE === 'false') return false;\n\n\t\tif (!message.member) {\n\t\t\ttry {\n\t\t\t\tmessage.member = await message.guild.members.fetch(message.author.id);\n\t\t\t} catch {\n\t\t\t\tthis.client.log.verbose('Failed to fetch member %s of %s', message.author.id, message.guild.id);\n\t\t\t}\n\t\t}\n\n\t\tconst channels = message.mentions.channels;\n\t\tconst members = [...message.mentions.members.values()];\n\t\tconst roles = [...message.mentions.roles.values()];\n\n\t\tif (message.member) {\n\t\t\tmembers.push(message.member);\n\t\t\troles.push(hoistedRole(message.member));\n\t\t} else {\n\t\t\tthis.client.log.warn('Message member does not exist');\n\t\t\tawait this.client.prisma.archivedUser.upsert({\n\t\t\t\tcreate: {},\n\t\t\t\tupdate: {},\n\t\t\t\twhere: {\n\t\t\t\t\tticketId_userId: {\n\t\t\t\t\t\tticketId,\n\t\t\t\t\t\tuserId: 'default',\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t});\n\t\t}\n\n\t\tfor (const role of roles) {\n\t\t\tconst data = {\n\t\t\t\tcolour: role.hexColor.slice(1),\n\t\t\t\tname: role.name,\n\t\t\t\troleId: role.id,\n\t\t\t\tticket: { connect: { id: ticketId } },\n\t\t\t};\n\t\t\tawait this.client.prisma.archivedRole.upsert({\n\t\t\t\tcreate: data,\n\t\t\t\tupdate: data,\n\t\t\t\twhere: {\n\t\t\t\t\tticketId_roleId: {\n\t\t\t\t\t\troleId: role.id,\n\t\t\t\t\t\tticketId,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t});\n\t\t}\n\n\t\tfor (const member of members) {\n\t\t\tconst data = {\n\t\t\t\tavatar: member.avatar || member.user.avatar, // TODO: save avatar in user/avatars/\n\t\t\t\tbot: member.user.bot,\n\t\t\t\tdiscriminator: member.user.discriminator,\n\t\t\t\tdisplayName: member.displayName ? encrypt(member.displayName) : null,\n\t\t\t\troleId: !!member && hoistedRole(member).id,\n\t\t\t\tticketId,\n\t\t\t\tuserId: member.user.id,\n\t\t\t\tusername: encrypt(member.user.username),\n\t\t\t};\n\t\t\tawait this.client.prisma.archivedUser.upsert({\n\t\t\t\tcreate: data,\n\t\t\t\tupdate: data,\n\t\t\t\twhere: {\n\t\t\t\t\tticketId_userId: {\n\t\t\t\t\t\tticketId,\n\t\t\t\t\t\tuserId: member.user.id,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t});\n\t\t}\n\n\t\tlet reference;\n\t\tif (message.reference) reference = await message.fetchReference();\n\n\t\tconst messageD = {\n\t\t\tauthor: {\n\t\t\t\tconnect: {\n\t\t\t\t\tticketId_userId: {\n\t\t\t\t\t\tticketId,\n\t\t\t\t\t\tuserId: message.author?.id || 'default',\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tcontent: encrypt(\n\t\t\t\tJSON.stringify({\n\t\t\t\t\tattachments: [...message.attachments.values()],\n\t\t\t\t\tcomponents: [...message.components.values()],\n\t\t\t\t\tcontent: message.content,\n\t\t\t\t\tembeds: message.embeds.map(embed => ({\n\t\t\t\t\t\ttitle: embed.title,\n\t\t\t\t\t\tdescription: embed.description,\n\t\t\t\t\t\turl: embed.url,\n\t\t\t\t\t\ttimestamp: embed.timestamp,\n\t\t\t\t\t\tcolor: embed.color,\n\t\t\t\t\t\tfooter: embed.footer,\n\t\t\t\t\t\timage: embed.image,\n\t\t\t\t\t\tthumbnail: embed.thumbnail,\n\t\t\t\t\t\tauthor: embed.author,\n\t\t\t\t\t\tfields: embed.fields?.map(field => ({\n\t\t\t\t\t\t\tname: field.name,\n\t\t\t\t\t\t\tvalue: field.value,\n\t\t\t\t\t\t\tinline: field.inline\n\t\t\t\t\t\t})) || []\n\t\t\t\t\t})),\n\t\t\t\t\treference: reference ? reference.id : null,\n\t\t\t\t}),\n\t\t\t),\n\t\t\tcreatedAt: message.createdAt,\n\t\t\tedited: !!message.editedAt,\n\t\t\texternal,\n\t\t\tid: message.id,\n\t\t};\n\n\t\treturn await this.client.prisma.ticket.update({\n\t\t\tdata: {\n\t\t\t\tarchivedChannels: {\n\t\t\t\t\tupsert: channels.map(channel => {\n\t\t\t\t\t\tconst data = {\n\t\t\t\t\t\t\tchannelId: channel.id,\n\t\t\t\t\t\t\tname: channel.name,\n\t\t\t\t\t\t};\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tcreate: data,\n\t\t\t\t\t\t\tupdate: data,\n\t\t\t\t\t\t\twhere: {\n\t\t\t\t\t\t\t\tticketId_channelId: {\n\t\t\t\t\t\t\t\t\tchannelId: channel.id,\n\t\t\t\t\t\t\t\t\tticketId,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t};\n\t\t\t\t\t}),\n\t\t\t\t},\n\t\t\t\tarchivedMessages: {\n\t\t\t\t\tupsert: {\n\t\t\t\t\t\tcreate: messageD,\n\t\t\t\t\t\tupdate: messageD,\n\t\t\t\t\t\twhere: { id: message.id },\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twhere: { id: ticketId },\n\t\t});\n\t}\n};\n"
        }
    ]
}